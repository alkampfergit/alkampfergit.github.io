<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AzureDevOps on Codewrecks</title><link>https://www.codewrecks.com/tags/azuredevops/</link><description>Recent content in AzureDevOps on Codewrecks</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 08 Sep 2023 08:00:00 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/azuredevops/index.xml" rel="self" type="application/rss+xml"/><item><title>Azure DevOps: delete all unstable version of packages in feeds</title><link>https://www.codewrecks.com/post/azdo/misc/clean-artifacts-feed/</link><pubDate>Fri, 08 Sep 2023 08:00:00 +0200</pubDate><guid>https://www.codewrecks.com/post/azdo/misc/clean-artifacts-feed/</guid><description>Azure DevOps has a dedicated section for artifacts that allows you to store NuGet, NPM feeds, and more. Thanks to its integration with pipelines, very often, automatic pipelines are generated that publish packages with every commit in the repository. This way, we have the opportunity to have all versions for all dev branches.
This approach is needed because the usual flow when you develop a new feature in a package is the following:</description></item><item><title>More secure Azure DevOps Pipelines API connection thanks to OAuth Tokens</title><link>https://www.codewrecks.com/post/azdo/api/reschedule-pr-check-use-oauth2-tokens/</link><pubDate>Sun, 19 Mar 2023 07:12:42 +0200</pubDate><guid>https://www.codewrecks.com/post/azdo/api/reschedule-pr-check-use-oauth2-tokens/</guid><description>In a previous blog post, I discussed how to reschedule the check of a pull request using a simple PowerShell script within an Azure DevOps pipeline. This time, I&amp;rsquo;ll explain how to avoid using Personal Access Tokens for authentication and switch to a more secure alternative.
The issue with Personal Access Tokens is that they are bearer token, which means if they&amp;rsquo;re lost or accidentally leaked in logs, anyone with access to the token can use it to access your services.</description></item><item><title>Azure DevOps: importance of stable tests in pull requests</title><link>https://www.codewrecks.com/post/azdo/misc/importance-of-stable-test-in-pull-requests/</link><pubDate>Wed, 01 Feb 2023 07:00:42 +0000</pubDate><guid>https://www.codewrecks.com/post/azdo/misc/importance-of-stable-test-in-pull-requests/</guid><description>Pull Requests are the heartbeat of a project, and it is probably one of the reason to move to Git if you still are in a different source control. Actually a Pull Requests introduce this enormous advantage in a team
You know when a feature/bugfix branch is ready to be inspected by the team A single place of discussion Automatic Merge and tests run on merge result Etc. Actually you have a lots of other advantages, but I want to concentrate the attention on test run.</description></item><item><title>Quick Peek at Microsoft Security Code Analysis Credential Scanner</title><link>https://www.codewrecks.com/post/old/2019/11/quick-peek-at-microsoft-security-code-analysis-credential-scanner/</link><pubDate>Sat, 23 Nov 2019 16:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2019/11/quick-peek-at-microsoft-security-code-analysis-credential-scanner/</guid><description>Microsoft Security Code Analysis contains a set of Tasks for Azure DevOps pipeline to automate some security checks during building of your software. Automatic security scanning tools are not a substitute in any way for human security analysis, remember: if you develop code ignoring security, no tool can save you.
Despite this fact, there are situation where static analysis can really give you benefit, because it can avoid you some simple and silly errors, that can lead to troubles.</description></item><item><title>Release app with Azure DevOps Multi Stage Pipeline</title><link>https://www.codewrecks.com/post/old/2019/10/release-app-with-azure-devops-multi-stage-pipeline/</link><pubDate>Mon, 21 Oct 2019 15:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2019/10/release-app-with-azure-devops-multi-stage-pipeline/</guid><description>MultiStage pipelines are still in preview on Azure DevOps, but it is time to experiment with real build-release pipeline, to taste the news. The Biggest limit at this moment is that you can use Multi Stage to deploy in Kubernetes or in the cloud, but there is not support for agent in VM (like standard release engine). This support will be added in the upcoming months but if you use azure or kubernetes as a target you can already use it.</description></item><item><title>How to delete content in Azure DevOps wiki</title><link>https://www.codewrecks.com/post/old/2019/07/how-to-delete-content-in-azure-devops-wiki/</link><pubDate>Fri, 05 Jul 2019 14:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2019/07/how-to-delete-content-in-azure-devops-wiki/</guid><description>Today I got a simple but interesting question about Azure DevOps, how can I completely delete the content of the wiki ? There are not so many reason for this, but sometimes you really want to start from scratch. Now suppose you have your wiki:
Figure 1: Wiki with a simple page
You have created some pages, you played a little bit with the wiki, you attached some cute pets photo and content to the wiki itself, maybe just to gain familiarity with the wiki itself.</description></item><item><title>Azure DevOps and SecDevOps</title><link>https://www.codewrecks.com/post/old/2019/05/azure-devops-and-secdevops/</link><pubDate>Sun, 19 May 2019 16:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2019/05/azure-devops-and-secdevops/</guid><description>One of the cool aspect of Azure DevOps is the extendibility through marketplace api, and for security you can find a nice marketplace addin called Owasp ZAP (https://marketplace.visualstudio.com/items?itemName=kasunkodagoda.owasp-zap-scan) that can be used to automate OWASP test for web application.
You can also check this nice article in MSDN https://devblogs.microsoft.com/premier-developer/azure-devops-pipelines-leveraging-owasp-zap-in-the-release-pipeline/ that explain how you can leverage OWASP ZAP analysis during a deploy with release pipeline.
REally good stuff to read / use.</description></item><item><title>Converting Existing pipeline to YAML how to avoid double builds</title><link>https://www.codewrecks.com/post/old/2019/05/converting-existing-pipeline-to-yaml-how-to-avoid-double-builds/</link><pubDate>Sat, 04 May 2019 05:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2019/05/converting-existing-pipeline-to-yaml-how-to-avoid-double-builds/</guid><description>Actually YAML build is the preferred way to create Azure DevOps Build Pipeline and converting existing build is really simple thanks to the “View YAML” button that can simply convert every existing pipeline in a YAML definition. figure 1: Converting existing Pipeline in YAML is easy with the View YAML button present in editor page.
The usual process is, start a new feature branch to test pipeline conversion to YAML, create the YAML file and a Pipeline based on it, then start testing.</description></item><item><title>How to edit a YAML Azure DevOps Pipeline</title><link>https://www.codewrecks.com/post/old/2019/04/how-to-edit-a-yaml-azure-devops-pipeline/</link><pubDate>Sun, 14 Apr 2019 08:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2019/04/how-to-edit-a-yaml-azure-devops-pipeline/</guid><description>I cannot stress you enough on how better is the experience of having builds defined in code than having build definition on the server , so I’m here to convince you to move to the new YAML build system in Azure DevOps :).
Having build definition in Code gives you many benefits, the first is that builds evolve with code branches.
If you still think that editing a YAML file is a daunting experience because you have tons of possible tasks and configuration to use, take a peek to the Azure Pipeline extension Visual Studio Code Addin, that brings intellisense for your pipeline editing in Visual Studio Code.</description></item><item><title>WIQL editor extension For Azure DevOps</title><link>https://www.codewrecks.com/post/old/2019/02/wiql-editor-extension-for-azure-devops/</link><pubDate>Sun, 03 Feb 2019 15:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2019/02/wiql-editor-extension-for-azure-devops/</guid><description>One of the nice feature of Azure DevOps is extendibility, thanks to REST API you can write addins or standalone programs that interacts with the services. One of the addin that I like the most is the Work Item Query Language Editor, a nice addin that allows you to interact directly with the underling syntax of Work Item query.
Once installed, whenever you are in query Editor, you have the ability to directly edit the query with WIQL syntax, thanks to the “Edit Query wiql” menu entry.</description></item><item><title>TFS 2019 Change Work Item Type and Move Between Team Project</title><link>https://www.codewrecks.com/post/old/2018/12/tfs-2019-change-work-item-type-and-move-between-team-project/</link><pubDate>Sun, 16 Dec 2018 17:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2018/12/tfs-2019-change-work-item-type-and-move-between-team-project/</guid><description>When the first version of Team Foundation Server on Azure was presented, it has less feature than on-premise version, but actually Azure Dev Ops has changed the situation. The reality is that new features are first introduced into Azure Dev Ops, then on Azure Dev Ops Server (the on-premise version). A couple of features were really missing on the on-premise version, the ability to change Work Item Type and the ability to move Work Items between projects.</description></item><item><title>Azure DevOps pipelines and Sonar Cloud gives free analysis to your OS project</title><link>https://www.codewrecks.com/post/old/2018/10/azure-devops-pipelines-and-sonar-cloud-gives-free-analysis-to-your-os-project/</link><pubDate>Wed, 10 Oct 2018 21:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2018/10/azure-devops-pipelines-and-sonar-cloud-gives-free-analysis-to-your-os-project/</guid><description>In previous post I’ve shown how easy is to create a YAML definition to create a build definition to build your GitHub Open Source project in Azure DevOps, without the need to spend any money nor installing anything on you server.
Once you create a default build that compile and run tests, it would be super nice to create a free account in SonarCloud to have your project code to be analyzed automatically from the Azure Pipeline you’ve just created.</description></item><item><title>Code in GitHub Build in Azure DevOps and for FREE</title><link>https://www.codewrecks.com/post/old/2018/10/code-in-github-build-in-azure-devops-and-for-free/</link><pubDate>Tue, 09 Oct 2018 21:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2018/10/code-in-github-build-in-azure-devops-and-for-free/</guid><description>When you create a new open source project in GitHub, one of the first step is to setup continuous integration; the usual question is: What CI engine should I use? Thanks to Azure Dev Ops, you can use free build pipelines to build projects even if they are in GitHub (not hosted in Azure Dev Ops)
Azure Dev Ops, formerly known as VSTS, allows to define free build pipelines to build projects in GitHub</description></item><item><title>Converting PowerShell Task in YAML</title><link>https://www.codewrecks.com/post/old/2018/08/converting-powershell-task-in-yaml/</link><pubDate>Tue, 07 Aug 2018 17:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2018/08/converting-powershell-task-in-yaml/</guid><description>YAML Builds have many advantages over traditional build definitions, especially because YAML build definitions follows branching of code , a killer feature that is fantastic if you use GitFlow.
YAML Build definitions are stored in code, this allows them to follow branches, minimizing the need to maintain builds that should build code in different moment in time.
As an example I have a build where I have tasks to publish some Web Sites, if I had a new Web Site to publish, I can add another task in YAML build, but the build still work for older branches, especially for the master branch that represent my code in production.</description></item></channel></rss>