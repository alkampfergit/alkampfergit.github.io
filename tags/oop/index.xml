<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OOP on Codewrecks</title><link>https://www.codewrecks.com/tags/oop/</link><description>Recent content in OOP on Codewrecks</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 02 Jan 2012 15:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/oop/index.xml" rel="self" type="application/rss+xml"/><item><title>Fluent interface for factory to create hierarchy of objects</title><link>https://www.codewrecks.com/post/old/2012/01/fluent-interface-for-factory-to-create-hierarchy-of-objects/</link><pubDate>Mon, 02 Jan 2012 15:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/01/fluent-interface-for-factory-to-create-hierarchy-of-objects/</guid><description>Fluent interfaces are great for a various amount of situations because they permit to create a simple DSL using only the base capabilities of your language of choice. I like very much Fluent Interfaces especially to create Factories to avoid messing with several constructors when your classes are complex to create.
The model
Suppose you want to create a fluent Factory for a * Character *abstract class that has two concrete classes called: Warriors and Wizards, with this model you want to create a Fluent Interface to create object.</description></item><item><title>Traffic Light Experiment</title><link>https://www.codewrecks.com/post/old/2011/11/traffic-light-experiment/</link><pubDate>Mon, 07 Nov 2011 17:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/11/traffic-light-experiment/</guid><description>Suppose you need to implement a traffic light manager for a crossroad and you decide to approach with a DDD style to experiment some patterns and techniques. Going with DDD-Like approach in such a simple scenario is probably not the best idea, but the aim of this little experiment is trying to approach a problem trying to follow “object thinking”.
A classic approach to this problem usually produces a TrafficLight class with a bunch of properties and probably a CrossRoad or TrafficLightManager class with all the logic, that basically read the status of Traffic Lights elaborates these data and change the status accordingly.</description></item><item><title>Leverage the concept of 'state' of your entities</title><link>https://www.codewrecks.com/post/old/2011/06/leverage-the-concept-of-state-of-your-entities/</link><pubDate>Mon, 13 Jun 2011 07:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/06/leverage-the-concept-of-state-of-your-entities/</guid><description>One of the interesting ideas found in Radical and other implementations of DDD architectures, is implementing properties of Domain objects in a slightly different way from the standard, using something like a dictionary to store values of properties. When we want to implement a property for a Domain class you usually end up with similar code.
1 2 3 4 5 6 7 8 public String Property { get; set; } private string _fieldBasedProperty; public String FieldBasedProperty { get { return _fieldBasedProperty; } set { _fieldBasedProperty = value; } } Both of them use a private field to store the real value of the property, the first one is a compact form (I to not like it for Domain object because it gives you no control on state changing of the object), the second one is the standard code to implement a property with a Backing field.</description></item><item><title>EntityLock implement a logic locking strategy in my domain</title><link>https://www.codewrecks.com/post/old/2011/05/entitylock-implement-a-logic-locking-strategy-in-my-domain/</link><pubDate>Wed, 25 May 2011 15:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/05/entitylock-implement-a-logic-locking-strategy-in-my-domain/</guid><description>I have a domain where one of the business operation consists of analysis of some entities, for each entity we need to do complex analysis involving external servers and until now we could live with a single server that sequentially analyze those entities one after another.
All works good, but we reach a point where the amount of work reached the capacity of the Analyzer server, so we need to change the analysis algorithm to parallelize the analysis.</description></item></channel></rss>