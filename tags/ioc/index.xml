<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IoC on Codewrecks</title><link>https://www.codewrecks.com/tags/ioc/</link><description>Recent content in IoC on Codewrecks</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 15 May 2016 16:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/ioc/index.xml" rel="self" type="application/rss+xml"/><item><title>Decide when CastleWindsor Startable Facility starts your components</title><link>https://www.codewrecks.com/post/old/2016/05/decide-when-castle-windsor-startable-facility-starts-your-components/</link><pubDate>Sun, 15 May 2016 16:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2016/05/decide-when-castle-windsor-startable-facility-starts-your-components/</guid><description>&lt;p>&lt;a href="https://github.com/castleproject/Windsor/blob/master/docs/startable-facility.md">Castle.Windsor Startable facility&lt;/a> is a nice facility that automatically starts component that implements a specific interface (IStartable) or components registered with specific extensions method (ex StartUsingMethod).&lt;/p>
&lt;p>This approach is really nice, and the Facility has different way to work, the old aggressive mode that &lt;strong>try to start a component immediately after is registered, and another, more useful, that starts a component only when all its dependencies are registered.&lt;/strong> This feature is helpful, because it avoid you to worry about order of registration.&lt;/p></description></item><item><title>Lifecycle of singleton objects</title><link>https://www.codewrecks.com/post/old/2011/05/lifecycle-of-singleton-objects/</link><pubDate>Fri, 06 May 2011 08:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/05/lifecycle-of-singleton-objects/</guid><description>&lt;p>Some days ago I blogged about an implementation of persistent cache component based on Managed Esent and &lt;a href="http://managedesent.codeplex.com/wikipage?title=PersistentDictionaryDocumentation">PersistentDictionary&lt;/a>. This component is injected into other components thanks to Inversion of Control and it is a &lt;em>&lt;a href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton&lt;/a>&lt;/em> object.&lt;/p>
&lt;p>&lt;a target="_blank" href="http://zenit.senecac.on.ca/wiki/imgs/Singleton_UML.png"> &lt;img src="http://zenit.senecac.on.ca/wiki/imgs/Singleton_UML.png" alt="External Image" />&lt;/a>&lt;/p>
&lt;p>Being a singleton is a requisite because it permits to different dependent objects to share the same cache, moreover &lt;em>PersistentDictionary&lt;/em> does not permit to have multiple instances that insists on the same directory. This will make EsentCache a perfect candidate of Singleton Object Pattern. Now another dilemma arise, &lt;em>since PersistentDictionary implements IDisposable to flush all resources into disk, who will call Dispose on a Singleton object?&lt;/em>&lt;/p></description></item><item><title>Use IoC in the UI</title><link>https://www.codewrecks.com/post/old/2009/09/use-ioc-in-the-ui/</link><pubDate>Mon, 21 Sep 2009 06:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2009/09/use-ioc-in-the-ui/</guid><description>&lt;p>I have a UI that uses MVC pattern, and it communicates with the server through a service exposed with WCF. Now one of the most annoying stuff is a correct handling of all typical errors that could arise in such a situation. We can have different result when you call a service method&lt;/p>
&lt;ol>
&lt;li>The operation succeeded&lt;/li>
&lt;li>The operation failed for an exception of the server that was not handled&lt;/li>
&lt;li>The server is unreachable&lt;/li>
&lt;li>Validation of some object failed&lt;/li>
&lt;li>The serverÂ  fail with a specific reason that can be handled by the UI&lt;/li>
&lt;/ol>
&lt;p>All these situation lead to different behavior of the UI. As an example point 3 should show a message that suggest the user to check connectivity because the server is unreachable, while for point 2 we could simply show a message like &lt;em>the server encountered an error, try again and if the error persist contact the support&lt;/em>. For each point I have always the same sets of actions to do, and I want a way to handle this only in one single point.&lt;/p></description></item></channel></rss>