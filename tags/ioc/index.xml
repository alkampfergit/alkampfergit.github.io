<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IoC on Codewrecks</title><link>https://www.codewrecks.com/tags/ioc/</link><description>Recent content in IoC on Codewrecks</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 15 May 2016 16:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/ioc/index.xml" rel="self" type="application/rss+xml"/><item><title>Decide when CastleWindsor Startable Facility starts your components</title><link>https://www.codewrecks.com/post/old/2016/05/decide-when-castle-windsor-startable-facility-starts-your-components/</link><pubDate>Sun, 15 May 2016 16:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2016/05/decide-when-castle-windsor-startable-facility-starts-your-components/</guid><description>Castle.Windsor Startable facility is a nice facility that automatically starts component that implements a specific interface (IStartable) or components registered with specific extensions method (ex StartUsingMethod).
This approach is really nice, and the Facility has different way to work, the old aggressive mode that try to start a component immediately after is registered, and another, more useful, that starts a component only when all its dependencies are registered. This feature is helpful, because it avoid you to worry about order of registration.</description></item><item><title>Lifecycle of singleton objects</title><link>https://www.codewrecks.com/post/old/2011/05/lifecycle-of-singleton-objects/</link><pubDate>Fri, 06 May 2011 08:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/05/lifecycle-of-singleton-objects/</guid><description>Some days ago I blogged about an implementation of persistent cache component based on Managed Esent and PersistentDictionary. This component is injected into other components thanks to Inversion of Control and it is a Singleton object.
Being a singleton is a requisite because it permits to different dependent objects to share the same cache, moreover PersistentDictionary does not permit to have multiple instances that insists on the same directory. This will make EsentCache a perfect candidate of Singleton Object Pattern.</description></item><item><title>Use IoC in the UI</title><link>https://www.codewrecks.com/post/old/2009/09/use-ioc-in-the-ui/</link><pubDate>Mon, 21 Sep 2009 06:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2009/09/use-ioc-in-the-ui/</guid><description>I have a UI that uses MVC pattern, and it communicates with the server through a service exposed with WCF. Now one of the most annoying stuff is a correct handling of all typical errors that could arise in such a situation. We can have different result when you call a service method
The operation succeeded The operation failed for an exception of the server that was not handled The server is unreachable Validation of some object failed The serverÂ fail with a specific reason that can be handled by the UI All these situation lead to different behavior of the UI.</description></item></channel></rss>