<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MEF on Codewrecks</title><link>https://www.codewrecks.com/tags/mef/</link><description>Recent content in MEF on Codewrecks</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 13 Aug 2012 19:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/mef/index.xml" rel="self" type="application/rss+xml"/><item><title>Making Castle and MEF happy togheter</title><link>https://www.codewrecks.com/post/old/2012/08/making-castle-and-mef-happy-togheter/</link><pubDate>Mon, 13 Aug 2012 19:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/08/making-castle-and-mef-happy-togheter/</guid><description>&lt;p>If you use Mef to dynamically load handlers for your services (as described in &lt;a href="http://www.codewrecks.com/blog/index.php/2012/04/23/evolving-request-response-service-to-separate-contract-and-business-logic/">this post&lt;/a>), you will probably need to declare dependencies to various other software service. Since MEF is not born to handle dependencies, you will probably use other libraries for DI, Es. Castle.Windsor. Now the problem is “how can I make MEF and my IoC container living together happily with minimum effort?”. To keep everything simple you will need to understand typical scenario, you want to solve, a first problem you need to solve is “ &lt;strong>Mef imported classes should be able to declare dependencies on services defined in my primary IoC container engine§.&lt;/strong> The simplest solution you can use is using MEF attributes to declare dependencies from other service with the ImportAttribute.&lt;/p></description></item><item><title>Little Trick to generate ILogger with MEF based on type</title><link>https://www.codewrecks.com/post/old/2012/07/little-trick-to-generate-ilogger-with-mef-based-on-type/</link><pubDate>Tue, 03 Jul 2012 17:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/07/little-trick-to-generate-ilogger-with-mef-based-on-type/</guid><description>&lt;p>I’ve a little application that uses MEF to manage plugins, today I faced this problem, I have classes like this one.&lt;/p>
&lt;div class="highlight">&lt;div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TestExport&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [Import]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ILog Logger { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; }&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>
&lt;p>This is a standard class that declares an import on log4net.ILog interface and since this little program uses MEF to do all composition I’d like to avoid using Castle or other IoC libraries, &lt;strong>but I wish to use MEF to resolve ILog with the constraint that each class should have its own logger&lt;/strong> , a condition verified by this test.&lt;/p></description></item><item><title>Evolving Request Response service to separate contract and business logic</title><link>https://www.codewrecks.com/post/old/2012/04/evolving-request-response-service-to-separate-contract-and-business-logic/</link><pubDate>Mon, 23 Apr 2012 11:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/04/evolving-request-response-service-to-separate-contract-and-business-logic/</guid><description>&lt;p>Example &lt;a href="http://www.codewrecks.com/Files/requestresponsemef.zip">&lt;strong>can be downloaded here&lt;/strong>&lt;/a> &lt;strong>.&lt;/strong> I previously described a scenario where the customer needs a &lt;a href="www.codewrecks.com/blog/index.php/2012/03/12/basic-request-response-wcf-service/">really basic Request Response service in WCF&lt;/a>, the goal is being able to take &lt;a href="http://www.codewrecks.com/blog/index.php/2012/04/05/reson-behind-request-responseservice-in-wc/">advantage of a request / response structure&lt;/a>, but with an approach like: “&lt;em>the simpliest thing that could possibly works&lt;/em>”. This technique is usually needed to &lt;strong>introduce new architectural concepts in a team&lt;/strong> without requiring people to learn a huge amount of concepts in a single shot, a scenario that could ends in a  team that actively * &lt;strong>fight the new architecture because it is too complex&lt;/strong> *.&lt;/p></description></item><item><title>Customize output windows in Visual Studio</title><link>https://www.codewrecks.com/post/old/2012/01/customize-output-windows-in-visual-studio/</link><pubDate>Mon, 09 Jan 2012 18:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/01/customize-output-windows-in-visual-studio/</guid><description>&lt;p>I really like WPF for showing directly in the Visual Studio Output folder all binding errors, but one annoying stuff is that the output windows is usually crowded with all sort of stuff, so you have an hard life identifying the binding errors from all the other output contained in there. Since Visual Studio 2010 use WPF to render the output windows and use MEF for extension, modifying the aspect of the content of VS2010 is really simple. So I’ve created in few minutes a simple addin to hilite the databinding error in output windows, the example is based on the &lt;a href="http://code.msdn.microsoft.com/windowsdesktop/Diff-Classifier-e87ed723">Diff Classifier SDK&lt;/a> sample, that explains how to use the text classification feature of VS2010&lt;/p></description></item></channel></rss>