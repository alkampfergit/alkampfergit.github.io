<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ICriteria on Codewrecks</title><link>https://www.codewrecks.com/tags/icriteria/</link><description>Recent content in ICriteria on Codewrecks</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 23 Jul 2011 08:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/icriteria/index.xml" rel="self" type="application/rss+xml"/><item><title>Use Sql Server Query Hints with NHibernate HQL and ICriteria</title><link>https://www.codewrecks.com/post/old/2011/07/use-sql-server-query-hints-with-nhibernate-hql-and-icriteria/</link><pubDate>Sat, 23 Jul 2011 08:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/07/use-sql-server-query-hints-with-nhibernate-hql-and-icriteria/</guid><description>When you work with Big databases with many records and not uniform distribution of data into columns used for join or where conditions, you can have really bad performance problem due to Query Plan caching. I do not want to give a deep explanation of this problem, you can find information here, but I want to outline the general problem to make clear what is happening.
We can argue a lot why this problem happens in a database engine, but basically I have a really bad situation where the db stores data of multiple customers with really non uniform distribution of data (some of them have ~1000 rows for each table, others have ~100.</description></item><item><title>NHibernate ICriteria and filters</title><link>https://www.codewrecks.com/post/old/2009/10/nhibernate-icriteria-and-filters/</link><pubDate>Tue, 13 Oct 2009 09:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2009/10/nhibernate-icriteria-and-filters/</guid><description>I have a project where I need to access tables with millions of rows, the project was born without nhibernate so the database was not designed with ORM in mind. I decided to improve performances with an Indexed view that materialized a join between five tables, wrapped with another view that does a left outer joins with other 3 tables. Then I created an entity called XXXDto, and mapped with nhibernate, with update=false to prevent updating and pointed it to this view.</description></item></channel></rss>