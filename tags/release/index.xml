<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Release on Codewrecks</title><link>https://www.codewrecks.com/tags/release/</link><description>Recent content in Release on Codewrecks</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 05 Jan 2025 08:12:42 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/release/index.xml" rel="self" type="application/rss+xml"/><item><title>Azure DevOps Pills: Differences between old and new release pipeline</title><link>https://www.codewrecks.com/post/azdo/pills/release-new-and-old/</link><pubDate>Sun, 05 Jan 2025 08:12:42 +0200</pubDate><guid>https://www.codewrecks.com/post/azdo/pills/release-new-and-old/</guid><description>Happy New Year to everyone. Today I&amp;rsquo;ll deal with a common question I got from customer regarding Azure DevOps release pipeline. The problem arise because we already had a GUI based pipeline in the past and then we had a fully YAML pipeline so people are somewhat puzzled on which one to use in their scenario.
When you have two way to do the same thing you are often confused on which tool to use to reach your goal</description></item><item><title>Pill: Create an environment in an AzDo pipeline</title><link>https://www.codewrecks.com/post/azdo/pills/create-environment-on-pipeline/</link><pubDate>Tue, 19 Mar 2024 08:10:42 +0200</pubDate><guid>https://www.codewrecks.com/post/azdo/pills/create-environment-on-pipeline/</guid><description>Scenario: We have to create a new environment for a new customer, and an environment consists of some resources on Azure, plus an environment in azure DevOps to use with deploy pipeline. Since we are deploying with Azure DevOps pipeline, it makes sense to create everything for new customer environment with another pipeline.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 stages: - stage: create_environment jobs: - job: create_environment displayName: &amp;#34;Create environment if not present&amp;#34; pool: vmImage: windows-latest steps: - powershell: | write-Host &amp;#34;We are about to create the environment with api if not present&amp;#34; # Need to create the token in basic auth $AuthHeaders = @{ &amp;#34;Authorization&amp;#34; = &amp;#39;Basic &amp;#39; + [Convert]::ToBase64String([Text.</description></item><item><title>Azure DevOps multi stage pipeline environments</title><link>https://www.codewrecks.com/post/old/2019/11/azure-devops-multi-stage-pipeline-environments/</link><pubDate>Tue, 12 Nov 2019 18:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2019/11/azure-devops-multi-stage-pipeline-environments/</guid><description>In a previous post on releasing with Multi Stage Pipeline and YAML code I briefly introduced the concept of environments. In that example I used an environment called single_env and you can be surprised that, by default, an environment is automatically created when the release runs. This happens because an environment can be seen as sets of resources used as target for deployments, but in the actual preview version, in Azure DevOps, you can only add Kubernetes resources.</description></item><item><title>Release app with Azure DevOps Multi Stage Pipeline</title><link>https://www.codewrecks.com/post/old/2019/10/release-app-with-azure-devops-multi-stage-pipeline/</link><pubDate>Mon, 21 Oct 2019 15:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2019/10/release-app-with-azure-devops-multi-stage-pipeline/</guid><description>MultiStage pipelines are still in preview on Azure DevOps, but it is time to experiment with real build-release pipeline, to taste the news. The Biggest limit at this moment is that you can use Multi Stage to deploy in Kubernetes or in the cloud, but there is not support for agent in VM (like standard release engine). This support will be added in the upcoming months but if you use azure or kubernetes as a target you can already use it.</description></item><item><title>Build and Deploy AspNet App with Azure DevOps</title><link>https://www.codewrecks.com/post/old/2019/03/build-and-deploy-asp-net-app-with-azure-devops/</link><pubDate>Thu, 28 Mar 2019 19:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2019/03/build-and-deploy-asp-net-app-with-azure-devops/</guid><description>I’ve blogged in the past about deploying ASP.NET application, but lots of new feature changed in Azure DevOps and it is time to do some refresh of basic concepts. Especially in the field of web.config transform there is always lots of confusion and even if I’m an advocate of removing every configuration from files and source, it is indeed something that worth to be examined. &amp;gt; The best approach for configuration is removing then from source control, use configuration services, etc and move away from web.</description></item><item><title>Mounting network share in Release Definition</title><link>https://www.codewrecks.com/post/old/2017/08/mounting-network-share-in-release-definition/</link><pubDate>Mon, 21 Aug 2017 19:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2017/08/mounting-network-share-in-release-definition/</guid><description>Using Deployment Groups with Release Management in VSTS is really nice, because you can use a pull release model, where the agent is running on machines that are deployment target, and all scripts are executed locally (instead of using PowerShell Remoting and WinRM).
A typical release definition depends on artifacts produced by a build and with VSTS sometimes it is convenient to store build artifacts in a network share instead that on VSTS.</description></item><item><title>Running UAT tests in a VSTS TFS release</title><link>https://www.codewrecks.com/post/old/2017/08/running-uat-tests-in-a-vsts-tfs-release/</link><pubDate>Thu, 17 Aug 2017 07:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2017/08/running-uat-tests-in-a-vsts-tfs-release/</guid><description>I’ve blogged on how to run UAT and integration tests during a VSTS Build; that solution works quite well but probably is not the right way to proceed. Generally speaking that build does its work but I have two main concerns.
Executing test with remote execution requires installation of test agent and involves WinRm , a beast that is not so easy to tame outside a domain
I’m deploying the new version of the application with an XCopy deployment, that is different from a real deploy to production.</description></item></channel></rss>