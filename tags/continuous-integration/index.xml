<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Continuous Integration on Codewrecks</title><link>https://www.codewrecks.com/tags/continuous-integration/</link><description>Recent content in Continuous Integration on Codewrecks</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 30 Jun 2015 18:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/continuous-integration/index.xml" rel="self" type="application/rss+xml"/><item><title>Manage Artifacts with TFS Build vNext</title><link>https://www.codewrecks.com/post/old/2015/06/manage-artifacts-with-tfs-build-vnext/</link><pubDate>Tue, 30 Jun 2015 18:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2015/06/manage-artifacts-with-tfs-build-vnext/</guid><description>Artifacts and Build vNext Another big improvement of Build vNext in TFS and VSO is the ability to **explicitly manage the content of artifactsduring a build **. With the term Artifacts in Continuous Integration we are referring to every result of of the build that is worth publishing together with build result, to be further consumed by consumers of the build. Generally speaking think to artifacts as build binary outputs.</description></item><item><title>Deploy remotely with TFS build</title><link>https://www.codewrecks.com/post/old/2010/07/deploy-remotely-with-tfs-build/</link><pubDate>Sat, 10 Jul 2010 05:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2010/07/deploy-remotely-with-tfs-build/</guid><description>It is time to connect together a couple of posts of mine, in the first I simply explained how to deploy a web application to a remote machine with the use of Beyondexec2, in another one I explained how to create a simple tfs build, that actually does not build anything, but execute a simple workflow.
In this post I&amp;rsquo;ll cover a primitive build workflow to deploy the result of another build.</description></item><item><title>Wrap a MsBuild Custom task inside a custom action</title><link>https://www.codewrecks.com/post/old/2010/01/wrap-a-msbuild-custom-task-inside-a-custom-action/</link><pubDate>Tue, 19 Jan 2010 21:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2010/01/wrap-a-msbuild-custom-task-inside-a-custom-action/</guid><description>If you have an MSBuild custom task that you want to reuse in a TFS 2010 build workflow, you have two solution. The first is using the MsBuild activity as I described in this post, but this approach has a lot of limitations.
First of all it is clumsy, because you have to pass custom task parameters as arguments to msbuild, but the worst problem is that you lose the ability to use output properties of the custom task.</description></item><item><title>Log warning and errors in a custom action</title><link>https://www.codewrecks.com/post/old/2010/01/log-warning-and-errors-in-a-custom-action/</link><pubDate>Mon, 18 Jan 2010 20:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2010/01/log-warning-and-errors-in-a-custom-action/</guid><description>Some time ago I blogged about logging in custom action for TFS build 2010, I left out some details. Suppose you want to create a warning or an error and not a simple message, you need to create a specialized version of the LogWarning that logs a real warning.
You can do the same with errors.
These two methods permit you to log warnings and errors during a custom build action execution, let&amp;rsquo;s see how they affect the output.</description></item><item><title>Branching policies</title><link>https://www.codewrecks.com/post/old/2009/09/branching-policies/</link><pubDate>Tue, 15 Sep 2009 10:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2009/09/branching-policies/</guid><description>I just read this post of Martin Fowler, and I found it very interesting. In my opinion, even small projects will greatly benefit from Continuous Integration. Despite of the Branching policies that you choose, having a machine for CI is vital during the lifetime of a project.
Usually I do not like very much CherryPicking even if sometimes it cannot be avoided. In the Promiscuous Integration model, people are doing CherryPicking from other branches and this scares me.</description></item></channel></rss>