<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ORM on Codewrecks</title><link>https://www.codewrecks.com/tags/orm/</link><description>Recent content in ORM on Codewrecks</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sat, 12 May 2012 06:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/orm/index.xml" rel="self" type="application/rss+xml"/><item><title>Misusing an ORM</title><link>https://www.codewrecks.com/post/old/2012/05/misusing-an-orm/</link><pubDate>Sat, 12 May 2012 06:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/05/misusing-an-orm/</guid><description>&lt;p>I’ve blogged some time ago that I’m starting to &lt;a href="http://www.codewrecks.com/blog/index.php/2011/10/27/square-peg-in-a-round-hole/">consider ORM an Antipattern&lt;/a>, and recently Mr Fowler &lt;a href="http://martinfowler.com/bliki/OrmHate.html">posted similar thoughts&lt;/a> in his bliki, moreover I have the pleasure to be one of the organizer of the &lt;a href="http://ravendb.net/events/82/3-days-ravendb-training-in-italy">first RavenDB official Course in Italy&lt;/a>, with my dear friend &lt;a href="http://milestone.topics.it/">Mauro&lt;/a> as teacher.&lt;/p>
&lt;p>Since I’m strongly convinced that in a full OOP approach to problem &lt;strong>objects should not have nor setter nor getter&lt;/strong> , most of the work and complexities of an ORM is simply not needed, because you usually retrieve objects from the storage with only one function &lt;strong>GetById&lt;/strong> and nothing else. In my long experience with NHibernate, I verified that most of the problem arise when you need to &lt;strong>show data in UI in specific format and you start to write complex Query&lt;/strong> in HQL or ICRiteria or LINQ, then you need to spend time with NHProfiler to understand if the queries are good enough to run on production system and when objects changes a little bit &lt;strong>you need to rewrite a lot of code to suite the new Object Model.&lt;/strong> This last point is the real pain point in DDD, where you usually should create Object Model that will be manipulated a lot before reaching a good point, after all the main value of DDD approach is being able to create a dialog with a DOMAIN EXPERT and it is impossible to find a good Object Models at the first tentative. If refactoring a model become painful, you are not allowed to modify it with easy, you are going away from DDD approach.&lt;/p></description></item><item><title>Square peg in a round Hole</title><link>https://www.codewrecks.com/post/old/2011/10/square-peg-in-a-round-hole/</link><pubDate>Thu, 27 Oct 2011 07:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/10/square-peg-in-a-round-hole/</guid><description>&lt;p>After lots of year working with NHibernate I started to think that probably the whole concept of ORM can be considered an Antipattern. Some people prefer a “classic” approach to the problem, * &lt;strong>data&lt;/strong> *is the key concept and most of the logic is inside a storage based on &lt;a href="http://en.wikipedia.org/wiki/Relational_model">Relational Model&lt;/a>.&lt;/p>
&lt;p>Is this wrong?&lt;/p>
&lt;p>Absolutely not, after all, for many years this was the preferred way to structure your application, and it worked quite well, but after OOP has come to life, a lot of people started appreciating this new paradigm of programming and started to think in terms of “ &lt;strong>objects&lt;/strong> ” instead of “ &lt;strong>data&lt;/strong> ”.&lt;/p></description></item><item><title>Entity Framework a super dataset</title><link>https://www.codewrecks.com/post/old/2011/06/entity-framework-a-super-dataset/</link><pubDate>Thu, 09 Jun 2011 07:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/06/entity-framework-a-super-dataset/</guid><description>&lt;p>Entity Framework is quite a good product, but in my opinion still misses some point to be called an ORM. I must admit that I never used the 4.1 Code first in real project, but there are some stuff that still does not convince me when using EF.&lt;/p>
&lt;h3 id="when-i-decide-to-use-ef-and-not-nh">When I decide to use EF (and not NH)&lt;/h3>
&lt;p>Sometimes I need to access small legacy databases to do a small amount of operations and I must admit that adding a EF Model from Visual Studio is a matter of seconds and the LINQ provider of EF is quite good so it is a valuable alternative to create a quick DAL. I have a simple database (four tables), I created an EF model, and then issue this query.&lt;/p></description></item><item><title>Do you ORM</title><link>https://www.codewrecks.com/post/old/2010/11/do-you-orm/</link><pubDate>Fri, 05 Nov 2010 19:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2010/11/do-you-orm/</guid><description>&lt;p>I really believe that I could not live anymore without ORM, and this is one simple reason.&lt;/p>
&lt;p>Suppose in NorthWind you should query for all Customers that have at least four orders where the total discount  is greater than 100.&lt;/p>
&lt;p>&lt;a href="https://www.codewrecks.com/blog/wp-content/uploads/2010/11/image4.png">&lt;a target="_blank" href="https://www.codewrecks.com/blog/wp-content/uploads/2010/11/image_thumb4.png"> &lt;img src="https://www.codewrecks.com/blog/wp-content/uploads/2010/11/image_thumb4.png" alt="image" />&lt;/a>&lt;/a>&lt;/p>
&lt;p>&lt;strong>Figure1:&lt;/strong> &lt;em>LINQ query to select all customers that have at least three orders with total discount greater than 100&lt;/em>&lt;/p>
&lt;p>Doing this in EF with a LINQ query is really simple (Figure 1), because you can express it with condition on the object model, and you can use the Count() LINQ operator and calculate the discount with simple math. The most important part is that you could be a SQL newbie, but you are still able to create a complex query. Now suppose that you should also paginate this result server side.&lt;/p></description></item></channel></rss>