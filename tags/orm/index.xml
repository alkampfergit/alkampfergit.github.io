<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ORM on Codewrecks</title><link>https://www.codewrecks.com/tags/orm/</link><description>Recent content in ORM on Codewrecks</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 12 May 2012 06:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/orm/index.xml" rel="self" type="application/rss+xml"/><item><title>Misusing an ORM</title><link>https://www.codewrecks.com/post/old/2012/05/misusing-an-orm/</link><pubDate>Sat, 12 May 2012 06:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/05/misusing-an-orm/</guid><description>I’ve blogged some time ago that I’m starting to consider ORM an Antipattern, and recently Mr Fowler posted similar thoughts in his bliki, moreover I have the pleasure to be one of the organizer of the first RavenDB official Course in Italy, with my dear friend Mauro as teacher.
Since I’m strongly convinced that in a full OOP approach to problem objects should not have nor setter nor getter , most of the work and complexities of an ORM is simply not needed, because you usually retrieve objects from the storage with only one function GetById and nothing else.</description></item><item><title>Square peg in a round Hole</title><link>https://www.codewrecks.com/post/old/2011/10/square-peg-in-a-round-hole/</link><pubDate>Thu, 27 Oct 2011 07:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/10/square-peg-in-a-round-hole/</guid><description>After lots of year working with NHibernate I started to think that probably the whole concept of ORM can be considered an Antipattern. Some people prefer a “classic” approach to the problem, * data *is the key concept and most of the logic is inside a storage based on Relational Model.
Is this wrong?
Absolutely not, after all, for many years this was the preferred way to structure your application, and it worked quite well, but after OOP has come to life, a lot of people started appreciating this new paradigm of programming and started to think in terms of “ objects ” instead of “ data ”.</description></item><item><title>Entity Framework a super dataset</title><link>https://www.codewrecks.com/post/old/2011/06/entity-framework-a-super-dataset/</link><pubDate>Thu, 09 Jun 2011 07:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/06/entity-framework-a-super-dataset/</guid><description>Entity Framework is quite a good product, but in my opinion still misses some point to be called an ORM. I must admit that I never used the 4.1 Code first in real project, but there are some stuff that still does not convince me when using EF.
When I decide to use EF (and not NH) Sometimes I need to access small legacy databases to do a small amount of operations and I must admit that adding a EF Model from Visual Studio is a matter of seconds and the LINQ provider of EF is quite good so it is a valuable alternative to create a quick DAL.</description></item><item><title>Do you ORM</title><link>https://www.codewrecks.com/post/old/2010/11/do-you-orm/</link><pubDate>Fri, 05 Nov 2010 19:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2010/11/do-you-orm/</guid><description>I really believe that I could not live anymore without ORM, and this is one simple reason.
Suppose in NorthWind you should query for all Customers that have at least four orders where the total discount is greater than 100.
Figure1: LINQ query to select all customers that have at least three orders with total discount greater than 100
Doing this in EF with a LINQ query is really simple (Figure 1), because you can express it with condition on the object model, and you can use the Count() LINQ operator and calculate the discount with simple math.</description></item></channel></rss>