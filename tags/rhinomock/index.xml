<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RhinoMock on Codewrecks</title><link>https://www.codewrecks.com/tags/rhinomock/</link><description>Recent content in RhinoMock on Codewrecks</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 06 May 2010 09:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/tags/rhinomock/index.xml" rel="self" type="application/rss+xml"/><item><title>AutoMockingContainer and mock used in the constructor</title><link>https://www.codewrecks.com/post/old/2010/05/automockingcontainer-and-mock-used-in-the-constructor/</link><pubDate>Thu, 06 May 2010 09:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2010/05/automockingcontainer-and-mock-used-in-the-constructor/</guid><description>&lt;p>I use a custom version of AutoMockingContainer based on the class used in &lt;a href="http://blog.eleutian.com/CommentView,guid,762249da-e25a-4503-8f20-c6d59b1a69bc.aspx">this blog&lt;/a>. The standard approach does not work for object that depends on some interface in the constructor, but actually uses that interface in the constructor and you need to set expectation on it.&lt;/p>
&lt;p>Basically you need a way to intercept the generation of mock and configure before the constructor of the dependant object is created. This is achieved with a simple trick, first of all the AutoMockingContainer implemnts a specific interface&lt;/p></description></item><item><title>Refactor to testability</title><link>https://www.codewrecks.com/post/old/2010/04/refactor-to-testability/</link><pubDate>Wed, 07 Apr 2010 13:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2010/04/refactor-to-testability/</guid><description>&lt;p>One of the reason why people do not write tests, is that some code is difficult to test, and one of the main reason for this difficulty is coupling. The obvious solution is to write loosely coupled code from the beginning, but if you are working with legacy code this option is not applicable.&lt;/p>
&lt;p>The problem is that if you have no test and the code is difficult to test you avoid to refactor; after all, if everything works as expected, why you should introduce bug with refactoring? The reason is that sometimes &lt;a href="http://en.wikipedia.org/wiki/Technical_debt">technical debt&lt;/a> is so high, that code is unmanteniable, and you are forced to refactor.&lt;/p></description></item></channel></rss>