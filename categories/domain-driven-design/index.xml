<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Domain Driven Design on Codewrecks</title><link>https://www.codewrecks.com/categories/domain-driven-design/</link><description>Recent content in Domain Driven Design on Codewrecks</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 13 Aug 2013 18:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/categories/domain-driven-design/index.xml" rel="self" type="application/rss+xml"/><item><title>Domain Driven Design for security</title><link>https://www.codewrecks.com/post/old/2013/08/domain-driven-design-for-security/</link><pubDate>Tue, 13 Aug 2013 18:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2013/08/domain-driven-design-for-security/</guid><description>I’ve just seen this interesting video of Dan Bergh Johnsson on DDD Security and I must admit that I agree with Dan under many aspect. One of the real advantage of DDD is making business explicit, and this can help in so many places in your software, that even security can benefit of DDD. It is a video I suggest you to watch, because is really small and it can open up a lot of discussion on Value Objects , one of the most useful pattern when you work with DDD.</description></item><item><title>Scan all assembly of the directory to find DomainEvent Handlers and command executors</title><link>https://www.codewrecks.com/post/old/2012/08/scan-all-assembly-of-the-directory-to-find-domainevent-handlers-and-command-executors/</link><pubDate>Sat, 04 Aug 2012 08:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/08/scan-all-assembly-of-the-directory-to-find-domainevent-handlers-and-command-executors/</guid><description>Structures based on Commands, Events and respective handler are really flexible and to maximize this flexibility adopting a convention over configuration is the key of success. If you look at this simple playground project you can find that we adopted a convention where a domain handler is any object that implements the IDomainHandler marker interface and any public Method that returns void and accepts a single parameter that inherits from the base class DomainEvent is a method handler.</description></item><item><title>Convention over configuration Domain Event and Commanding</title><link>https://www.codewrecks.com/post/old/2012/07/convention-over-configuration-domain-event-and-commanding/</link><pubDate>Wed, 25 Jul 2012 14:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/07/convention-over-configuration-domain-event-and-commanding/</guid><description>If you are moving to a more DDD oriented architecture probably you will adopt a solution that uses Commands and Handlers. Commands are the requests sent to BOUNDED CONTEXT from users or from external systems , they are processed by Command Executors and usually execution is a matter of loading some AGGREGATE ROOT from the store and invoking Methods on it.
Even if you are not using EVENT SOURCING, (Es. you have your AGGREGATE ROOTS persisted on a SQL Database with NHibernate), you should leverage the concept of DOMAIN EVENTS letting each AGGREGATE ROOT to raise one or more DOMAIN EVENTS during execution of its methods.</description></item><item><title>Poor Man DDD</title><link>https://www.codewrecks.com/post/old/2012/07/poor-man-ddd/</link><pubDate>Fri, 06 Jul 2012 19:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/07/poor-man-ddd/</guid><description>Some of my friends are doing great stuff with DDD but it is difficult to do DDD in legacy projects that last for years and started with a classical structure of UI+domain(anemic)+ORM/DAL, so it seems that exploring the fascinating land of DDD is an option only for people that start to work on new project, but it is really true? Clearly the main advantage of DDD is not related to technical questions , but it is to be found in the approach to problem: dialogue with DOMAIN EXPERTS, establishing an UBIQUITOUS LANGUAGE , and so on, but some of the grounding technical concepts of DDD can be inserted in legacy applications built with standard techniques to bring some of the advantages of DDD in existing projects.</description></item><item><title>SimpleCQRS appliers and convention over configuration</title><link>https://www.codewrecks.com/post/old/2012/06/simplecqrs-appliers-and-convention-over-configuration/</link><pubDate>Mon, 25 Jun 2012 14:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/06/simplecqrs-appliers-and-convention-over-configuration/</guid><description>I was playing around with SimpleCQRS project because my friend Andrea started to work on it recently. We now have Mongo repository for the events so I forked the project to have a look on it and contribute to Andrea works. I’ve opened the solution, ran the program, created some InventoryItems, then I look into mongo database to verify if snapshot of objects are correctly taken but I found this.</description></item><item><title>Lightweight code generation to access private method to implement Event Sourcing</title><link>https://www.codewrecks.com/post/old/2012/06/lightweight-code-generation-to-access-private-method-to-implement-event-sourcing/</link><pubDate>Mon, 04 Jun 2012 15:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/06/lightweight-code-generation-to-access-private-method-to-implement-event-sourcing/</guid><description>I like really much to play with Expression Tree or Dynamic Code Generation, a couple of techniques useful to do fast reflection, to maintain all the coolness of reflection (Es. invoking non public members) but without incurring in the penalties of calling methods through pure reflection calls. There are really good libraries around the web, like FastReflect that internally uses the power of LCG to invoke private methods, but the main question is: why you should be use such a dirty technique ?</description></item><item><title>Traffic light say goodbye to public properties</title><link>https://www.codewrecks.com/post/old/2012/01/traffic-light-say-goodbye-to-public-properties/</link><pubDate>Mon, 30 Jan 2012 10:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/01/traffic-light-say-goodbye-to-public-properties/</guid><description>I’ve more to say about the Traffic Light example I explained in a previous post, if you look at that post, you can notice that the Domain is composed by properties that have only getter and not setters. This needs is explained in this post, where I explain why you should protect the status of your entities from external direct manipulation.
If I wish to use my simple Traffic-Light example in a class to teach OOP principle, it is not good enough, because it breaks the concept of Encapsulation.</description></item><item><title>Is my Domain Model really anemic</title><link>https://www.codewrecks.com/post/old/2012/01/is-my-domain-model-really-anemic/</link><pubDate>Mon, 23 Jan 2012 10:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/01/is-my-domain-model-really-anemic/</guid><description>I’m reading the exceptional Object Thinking book, full of interesting considerations about thinking with an Object Oriented mind. One of the main concept of the book is that quite often we are using objects in a procedural way so we are still in the realm of procedural programming even using inheritance, constructor, etc etc. As an example we can have a domain where each object is only a container for data (properties) and a bunch of other classes (services) are using that domain objects to accomplish business rules.</description></item><item><title>Fluent interface for factory to create hierarchy of objects</title><link>https://www.codewrecks.com/post/old/2012/01/fluent-interface-for-factory-to-create-hierarchy-of-objects/</link><pubDate>Mon, 02 Jan 2012 15:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2012/01/fluent-interface-for-factory-to-create-hierarchy-of-objects/</guid><description>Fluent interfaces are great for a various amount of situations because they permit to create a simple DSL using only the base capabilities of your language of choice. I like very much Fluent Interfaces especially to create Factories to avoid messing with several constructors when your classes are complex to create.
The modelSuppose you want to create a fluent Factory for a * Character *abstract class that has two concrete classes called: Warriors and Wizards, with this model you want to create a Fluent Interface to create object.</description></item><item><title>Advantage of DDD approach to problem</title><link>https://www.codewrecks.com/post/old/2011/11/advantage-of-ddd-approach-to-problem/</link><pubDate>Tue, 08 Nov 2011 18:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/11/advantage-of-ddd-approach-to-problem/</guid><description>If you read my last post, I explain how I solved a really stupid problem of managing a Traffic Light using OOP principles and the concept of Domain Events, now I want to emphasize some of the advantages you have using this approach.
One benefit is in unit testing, suppose you want to test that a traffic light in red state does not cancel the request of another Traffic Light that want to become green.</description></item><item><title>Traffic Light Experiment</title><link>https://www.codewrecks.com/post/old/2011/11/traffic-light-experiment/</link><pubDate>Mon, 07 Nov 2011 17:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/11/traffic-light-experiment/</guid><description>Suppose you need to implement a traffic light manager for a crossroad and you decide to approach with a DDD style to experiment some patterns and techniques. Going with DDD-Like approach in such a simple scenario is probably not the best idea, but the aim of this little experiment is trying to approach a problem trying to follow “object thinking”.
A classic approach to this problem usually produces a TrafficLight class with a bunch of properties and probably a CrossRoad or TrafficLightManager class with all the logic, that basically read the status of Traffic Lights elaborates these data and change the status accordingly.</description></item><item><title>Protect the status of your entities</title><link>https://www.codewrecks.com/post/old/2011/10/protect-the-status-of-your-entities/</link><pubDate>Thu, 20 Oct 2011 06:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/10/protect-the-status-of-your-entities/</guid><description>Encapsulation is one of the key concept of OOP, the status of an entity should be protected from external direct manipulation, state of an object can be changed only by the object itself so the object is always in Valid State. One of the classic example is protecting property that contains collection of elements in.NET, like properties of type ILIST&amp;lt;T&amp;gt;.
Suppose that your * Character *entity has a property called Weapons of type IList&amp;lt;Weapon&amp;gt;, directly exposed to the outside world; this is the perfect example of broken encapsulation, because the entity has no control over what it got added to that collection.</description></item><item><title>Role playing games resources that grow with time</title><link>https://www.codewrecks.com/post/old/2011/09/role-playing-games-resources-that-grow-with-time/</link><pubDate>Mon, 05 Sep 2011 07:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/09/role-playing-games-resources-that-grow-with-time/</guid><description>In a typical online web browser role playing game, usually players has resources, that are needed to create building, weapon etc etc, and those resources are timed based. In the domain the concepts is something like the player earn X energy each second.
This is a typical situation in a role playing web game and if you try to implement logic at database level you can find a lot of problems.</description></item><item><title>Leverage the concept of 'state' of your entities</title><link>https://www.codewrecks.com/post/old/2011/06/leverage-the-concept-of-state-of-your-entities/</link><pubDate>Mon, 13 Jun 2011 07:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/06/leverage-the-concept-of-state-of-your-entities/</guid><description>One of the interesting ideas found in Radical and other implementations of DDD architectures, is implementing properties of Domain objects in a slightly different way from the standard, using something like a dictionary to store values of properties. When we want to implement a property for a Domain class you usually end up with similar code.
1 2 3 4 5 6 7 8 public String Property { get; set; } private string _fieldBasedProperty; public String FieldBasedProperty { get { return _fieldBasedProperty; } set { _fieldBasedProperty = value; } } Both of them use a private field to store the real value of the property, the first one is a compact form (I to not like it for Domain object because it gives you no control on state changing of the object), the second one is the standard code to implement a property with a Backing field.</description></item><item><title>Domain Driven Design in search of a good sample</title><link>https://www.codewrecks.com/post/old/2011/05/domain-driven-design-in-search-of-a-good-sample/</link><pubDate>Fri, 13 May 2011 06:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2011/05/domain-driven-design-in-search-of-a-good-sample/</guid><description>Some time ago, I was speaking with my dear friend Mauro Servienti about Domain Driven Design and the hard time we have in making people understand the real reasons behind DDD, CQRS and all the concepts in the DDD ecosystem.
Maybe I&amp;rsquo;m wrong but in my opinion it is difficult to explain DDD with classic examples like Orders&amp;lt;-&amp;gt;products&amp;lt;-&amp;gt;Customers or similar examples. In Italy DDD is still not know by many people and there is the need to make them aware of the real reason behind OOP.</description></item></channel></rss>