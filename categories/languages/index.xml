<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Languages on Codewrecks</title><link>https://www.codewrecks.com/categories/languages/</link><description>Recent content in Languages on Codewrecks</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sat, 22 Nov 2008 05:00:37 +0200</lastBuildDate><atom:link href="https://www.codewrecks.com/categories/languages/index.xml" rel="self" type="application/rss+xml"/><item><title>Extend BindingList with filter functionality</title><link>https://www.codewrecks.com/post/old/2008/11/extend-bindinglist-with-filter-functionality/</link><pubDate>Sat, 22 Nov 2008 05:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2008/11/extend-bindinglist-with-filter-functionality/</guid><description>If you still work with windows forms and cannot move all of your projects to WPF, you probably gets annoyed by the limitation of the standard BindingList&amp;lt;T&amp;gt; included in the framework. In an old post I showed how can you create a specialized BindingList&amp;lt;T&amp;gt; to support generic Find() thanks to reflection, but this is not enough.
Another annoying limitation is that BindingList does not support IBindingListView. For those that does not knows this interface, it is the one used by the windows forms binding engine to support filtering and advanced sorting.</description></item><item><title>Story of a stupid bug difference between struct and class</title><link>https://www.codewrecks.com/post/old/2008/06/stupid-bug-difference-between-struct-and-class/</link><pubDate>Tue, 24 Jun 2008 07:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2008/06/stupid-bug-difference-between-struct-and-class/</guid><description>I’ve incurred in a very stupid bug this afternoon, I run test on a new version of a component and I see that a lot of exceptions are raised about violating unique constraint of a simple strongly typed dataset I use to log information in database.
After a brief look at the code I found that I create new guid with the instruction *new Guid(),*I was really surprised because I really know that new guid should be created with Guid.</description></item><item><title>A generic IComparerT that works with reflection</title><link>https://www.codewrecks.com/post/old/2007/07/a-generic-icomparer-that-works-with-reflection/</link><pubDate>Mon, 02 Jul 2007 06:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2007/07/a-generic-icomparer-that-works-with-reflection/</guid><description>Today I was speaking with a colleague about creating a generic IComparer&amp;lt;T&amp;gt; that is able to compare two object based on a property discovered through reflection. Such object will be very useful to sort or find object inside collection of objects when you work with a domain model. In a domain we usually have a lot of objects such as customer, order, and so on, and it happens to have an homogeneous collection of objects in memory that needs to be sorted.</description></item><item><title>C anonymous delegates and template pattern</title><link>https://www.codewrecks.com/post/old/2007/06/c-anonymous-delegates-and-template-pattern-2/</link><pubDate>Tue, 05 Jun 2007 01:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2007/06/c-anonymous-delegates-and-template-pattern-2/</guid><description>Yesterday I blogged on a slightly modified version of Ayende code posted here, this makes me reflect on template pattern of the GOF. Template pattern is one of the most useful pattern, and is used when you have a common block of code that is to be repeated in may part with a little customization. In the GOF the intent of the pattern is
Define the skeleton of an algorithm in an operation, deferring some steps to subclasses.</description></item><item><title>The old plain C language</title><link>https://www.codewrecks.com/post/old/2007/05/the-old-plain-c-language/</link><pubDate>Sun, 27 May 2007 22:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2007/05/the-old-plain-c-language/</guid><description>A friend of mine is taking a basic course in computer programming, and actually he is studying the basic of C language. Yesterday he told me that he must do a very simple exercise that will print on screen a triangle like this
XXXXXXXXXX
XXXXXXXXX
XXXXXXXX
And so on. He asked me if I could review his solution before he give his program to the teacher, because he is moving from the old house to a new house and actually he do not have access to a computer to try his solution.</description></item><item><title>Difference between C and VB simple add</title><link>https://www.codewrecks.com/post/old/2007/05/difference-between-c-and-vb-simple-add/</link><pubDate>Sat, 26 May 2007 00:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2007/05/difference-between-c-and-vb-simple-add/</guid><description>Sometimes differences between C# and VB could be subtle, for example consider these very simple two snippets of code, what they will print?
1 2 3 4 5 6 7 Sub Main() Console.WriteLine(“Result is “ + Sum(Integer.MaxValue, 1)) EndSub PublicFunction Sum(ByVal a AsInteger, ByVal b AsInteger) Return a + b EndFunction 1 2 3 4 5 6 7 static void Main(string[] args) { Console.WriteLine(“Result is “ + Sum(Int32.MaxValue, 1)); } public static Int32 Sum(Int32 a, Int32 b) { return a + b; } The first snipped written in VB throws a System.</description></item><item><title>Casting in Visual Basic NET</title><link>https://www.codewrecks.com/post/old/2007/05/casting-in-visual-basic-net/</link><pubDate>Tue, 15 May 2007 06:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2007/05/casting-in-visual-basic-net/</guid><description>In all type safe languages there is the concept of “casting”, an operation used to specify to the compiler that a variable of a certain Type has to be considered of different Type. Visual Basic has three operators to do a cast: DirectCast, CTypeand TryCast, each one behaving in a different way from the other. To understand the subtle differences from these three operators lets present a simple example.
PrivateSub DirectCastExample(ByVal obj AsObject)</description></item><item><title>Syntax vs Semantic</title><link>https://www.codewrecks.com/post/old/2007/05/syntax-vs-semantic/</link><pubDate>Sat, 12 May 2007 23:00:37 +0200</pubDate><guid>https://www.codewrecks.com/post/old/2007/05/syntax-vs-semantic/</guid><description>Yesterday I was reading a post of a friend of mine. In this post my friend complains that these two snippet of code produces very different result.
‘VB code: returns 1.2
Public Function TestDiv() As Double
Dim a As Int32 = 12
Dim b As Int32 = 10
Return a / b
End Function
//C# code: returns 1
public static Double TestDiv() {
Int32 a = 12;
Int32 b = 10;</description></item></channel></rss>